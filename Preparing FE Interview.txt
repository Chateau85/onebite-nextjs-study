FE 기술면접 대비

1. React
1) React App의 생명 주기(클래스형 : 여러 생명주기 메서드를 명시적으로 사용, 함수형 : useEffect 하나로 Mount/Update/Unmount 모두 표현)
    (1) Mounting (컴포넌트 생성) 
		컴포넌트가 DOM에 처음 나타날 때 실행되는 단계, constructor() : state 초기화, 메서드 바인딩 등, static getDerivedStateFromProps() : props로부터 state 동기화, render() : JSX 반환 → 실제 UI 생성, componentDidMount() : 마운트 직후 실행, 네트워크 요청, DOM 조작 등 초기화 작업
	(2) Updating (업데이트)
		props 또는 state가 변경되면 다시 렌더링 되는 단계, static getDerivedStateFromProps() : props/state 변경 시 호출, shouldComponentUpdate() : 렌더링 여부 결정 (성능 최적화 가능), render() : UI 갱신, getSnapshotBeforeUpdate() : DOM 업데이트 직전에 호출 (예: 스크롤 위치 저장), componentDidUpdate() : 업데이트 완료 후 실행 (DOM 조작, 서버 요청 등 가능)
	(3) Unmounting (제거)
		컴포넌트가 DOM에서 사라질 때 실행되는 단계, componentWillUnmount() : 이벤트 해제, 타이머 정리 등 리소스 정리 작업
	(4) 함수형 컴포넌트에서의 수명 주기(Hook)
		useEffect(..., []) : componentDidMount (처음 마운트될 때 1회 실행), useEffect(..., [state]) : componentDidUpdate (특정 state/props가 변경될 때 실행), return () => { ... } : componentWillUnmount (언마운트 시 실행)

2) Hooks
	- 로컬 상태: useState → 로직 복잡/여러 액션이면 useReducer / 컨텍스트 소비: useContext
	- DOM/타이머/외부 객체 보관: useRef (+ useImperativeHandle로 노출 제어)
	- 네트워크/구독/DOM 이벤트: useEffect (레이아웃 측정은 useLayoutEffect)
	- 리렌더 최적화: useMemo/useCallback / 대규모 업데이트 체감 최적화: useTransition/useDeferredValue
	- 외부 스토어 구독: useSyncExternalStore / Form 액션/상태: useActionState + useFormStatus
	- 낙관적 업데이트: useOptimistic / 리소스/Promise 직접 사용: use / 접근성 ID: useId
	(1) useState
		함수형 구성 요소에 상태를 추가하는 데 사용, 기본적으로 배열 return, const [count, setCount] = useState(0) 형태
	(2) useEffect
		구성 요소 내부에서 사이드 이펙 수행, useEffect(콜백함수()=>{}, 종속성 배열[]) 형태, 구성 요소의 수명 주기를 결정하는데 도움이 됨, 구성 요소가 처음/업데이트/재렌더링 될 때 무슨 일이 일어나는 지 정의
	(3) useLayoutEffect
		브라우저에 UI가 그려지기 전에 렌더링
	(4) useRef
		애플리케이션 내부의 항목을 참조하거나 생성, ref 객체.current로 접근
	(5) useContext
		애플리케이션 전체에서 상태를 관리하는 데 도움, prop 드릴링을 피하기 위해 사용, 사용하려면 앱 전체를 컨텍스트.provider 안에 래핑해야 함
	(6) useReducer(여러 가지를 받아서 하나의 것을 반환)
		더 복잡한 상태를 관리하기 위한 이상적인 솔루션, function reducer(state, action) {switch(action.type){case~return}} 선언 후, const [count, dispatch] = useReducer(reducer, 초기값) 형태로 사용
	(7) useMemo
		useMemo는 React에서 컴포넌트의 성능을 최적화하는 데 사용, 함수의 결과를 메모이제이션하여 비용이 많이 드는 계산을 최적화하는데 사용, const memo = useMemo(calculateValue, dependencies) 형태로 사용, useMemo에 넣는 계산이 눈에 띄게 느리고 종속성이 거의 변하지 않는 경우나 useMemo로 감싸진 컴포넌트에 props를 전달하는 경우 및 useMemo를 사용한 값이 다른 Hook의 종속성으로 사용될 수 있는 경우에 사용
	(8) useCallback
		리렌더링 간에 함수 자체를 캐싱, 컴포넌트의 최상위 레벨 또는 커스텀 Hook에서만 호출할 수 있으며, 반복문이나 조건문 내에서 호출할 수 없음
	(9) useImperativeHandle
		부모 컴포넌트에서 자식 컴포넌트의 내부 함수나 값에 접근할 수 있게 해주는 기능을 제공, 자식 컴포넌트에서 부모 컴포넌트로 특정 기능을 노출시키는 기능을 사용 가능, useImperativeHandle(ref, createHandle, dependencies?) 형태로 사용
	(10) useId
		useId는 컴포넌트의 최상위 수준에서 호출하여 고유한 ID를 생성, 특정 컴포넌트 내 특정 useId 와 관련된 고유 ID 문자열를 반환
	(11) useTransition
		백그라운드에서 UI의 일부를 렌더링할 수 있는 hook, const [isPending, startTransition] = useTransition() 형태로 사용
	(12) useDeferredValue
		UI의 일부 업데이트를 연기할 수 있는 hook, const deferredValue = useDeferredValue(value) 형태로 사용, 새로운 콘텐츠가 로드되는 동안 오래된 콘텐츠 표시
	(13) useActionState
		form 작업의 결과에 따라 상태를 업데이트할 수 있는 hook, const [state, formAction] = useActionState(increment, 0) 형태로 사용
	(14) useFormStatus
		마지막 form 제출의 상태 정보를 제공
	(15) useOptimistic
		UI를 낙관적으로 업데이트, 비동기 작업이 진행되는 동안 다른 상태를 표시, 일부 상태를 인수로 받아들이고 네트워크 요청과 같은 비동기 작업 기간 동안 다를 수 있는 해당 상태의 복사본을 반환, 현재 상태와 작업에 대한 입력을 가져오고 작업이 보류 중인 동안 사용할 낙관적 상태를 반환하는 함수를 제공, const [optimisticState, addOptimistic] = useOptimistic(state, (currentState, optimisticValue) => {}) 형태로 사용
	(16) 사용자 정의 hook
		hooks 폴더에 use 접두사를 붙인 jsx 파일로 작성, 컴포넌트의 최상위 레벨에서만 호출

3) 상태관리 라이브러리
	(1) Redux
		React 상태관리 라이브러리, 본질은 Node.js 모듈, 상태관리를 컴포넌트 밖에서 관리할 수 있게 되므로 전역 상태 저장소 제공과 props 드릴링 해결, Store-Action-Reducer로 구성, 두 가지 파라미터(state와 action)를 받아서 새로운 상태 객체를 만들어 반환, 상태가 바뀌면 구독하고 있던 컴포넌트에게 알림(listener 함수), dispatch 관리를 위해 redux-thunk, redux-saga 등의 미들웨어 필요(비동기 처리 복잡), 보일러플레이트 코드가 많음(action, connect, mapStateToProps, mapDispatchToProps…)
			Store는 상태가 관리되는 오직 하나의 공간컴포넌트와는 별개로 스토어라는 공간이 있어서 그 스토어 안에 앱에서 필요한 상태를 담음, 컴포넌트에서 상태 정보가 필요할 때 스토어에 접근
			Action은 앱에서 스토어에 운반할 데이터를 말하며, 자바스크립트 객체 형식으로 구성
			Reducer는 Action을 Store에 전달하기 위해 사용, Reducer가 주문을 보고 Store의 상태를 업데이트, Action을 Reducer에 전달하기 위해서는 dispatch() 메소드를 사용
	(2) Recoil
		페이스북에서 만든 상태관리 라이브러리, React 문법 친화적이며, 전역 상태 값도 React의 state처럼 간단한 get/set 인터페이스로 사용할 수 있는 boilerplate-free API를 제공, React와 개발 방향성이 같음(동시성 모드(Concurrent Mode)를 비롯한 다른 새로운 React의 기능들과의 호환 가능성), 비동기 처리를 간단하게 할 수 있음(추가 라이브러리 없이 recoil만으로 가능)
			Atoms는 state의 단위이며 업데이트와 구독이 가능합, atom 값을 읽는 컴포넌트들은 암묵적으로 atom을 구독하며 atom에 어떤 변화가 있다면 그 atom을 구독하는 모든 컴포넌트가 리렌더링, Atoms를 설정할 때는 atom()을 사용하, key와 default값을 선언 필수, key: 내부적으로 atom을 식별하는 데 사용되는 고유한 문자열, 어플리케이션 전체에서 다른 atom과 selector에 대해 고유해야 함(전역적으로 고유한 값을 가져야 하므로 네이밍 시 $와 같은 구분자를 붙여 사용하기도 함), default(atom의 초깃값. 다양한 타입을 사용할 수 있으며, 동일한 타입의 값을 나타내는 다른 atom이나 selector도 가능), atom을 설정할 때 Promise을 지정할 수 없으며, 비동기 함수를 사용하기 위해서는 selectors를 사용, 컴포넌트에서 atom을 읽고 쓸 수 있게 하기 위해서는 useRecoilState()를 사용, 기본값 대신 Recoil state를 인자로 받는 다는 것을 제외하면 React의 useState()와 상당히 유사한 형태, useRecoilState()는 상태값과, setter함수를 리턴, 이 hook은 암묵적으로 state를 구독하며 atom 값이 변경되면 컴포넌트가 자동적으로 리렌더링
			Selector는 전역 상태 값을 기반으로 어떤 계산을 통해 파생된 상태(derived state)를 반환하는 순수함수, get함수만 제공되면 Selector는 읽기만 가능한 RecoilValueReadOnly 객체를 반환, set 함수 또한 제공되며(optional) Selector는 쓰기 가능한 RecoilState 객체를 반환, get 매개변수를 이용하여 atom이나 다른 selector를 참조할 수 있음
			useRecoilState(): atom을 읽고, 쓰기 위해 사용. 컴포넌트는 atom을 구독 / useRecoilValue(): atom을 읽기만 할 때 사용, 컴포넌트는 atom을 구독 / useSetRecoilState(): atom을 쓰려고만 할 때 사용 / useResetRecoilState(): atom을 default 값으로 초기화 할 때 사용
	(3) Zustand
		작고 빠르며 확장 가능한 React 프로젝트에서 사용하는 상태 관리(Store) 라이브러리, 스토어(Store)를 사용해, 컴포넌트 간 공유할 데이터를 중앙에서 관리
		create 함수로 스토어를 생성, create 함수의 콜백은 set, get 매개변수를 가지며, 이를 통해 상태를 변경하거나 조회, create 함수의 콜백이 반환하는 객체에서의 속성은 상태(State)이고, 메소드는 액션(Action), create 함수 호출에서 반환하는 스토어 훅(Hook)은, useCountStore와 같이 use 접두사와 Store 접미사로 명명해 각 컴포넌트에서 사용, useShallow 훅을 사용하면 여러 상태(액션)을 한 번에 객체나 배열로 가져올 수 있음, 상태를 초깃값으로 되돌리는 기능이 필요한 경우 resetState 함수를 추가해 사용, set 함수의 두 번째 인수(기본값 false)로 true를 전달하면, 상태를 병합하지 않고 덮어씀
		타입스크립트를 사용할 때, 상태 타입을 직접 작성하지 않고 추론하도록 combine 미들웨어 사용 가능
		Immer 미들웨어를 사용하면, 중첩된 객체 상태를 보다 쉽게 변경 가능
		스토어 훅에서 subscribe 함수를 사용하면, 스토어의 모든 상태 변경을 구독(상태를 감지해 리스너(Listener)를 호출), subscribe 함수의 반환을 호출하면 구독을 해제, 모든 상태가 아닌 특정 상태 변경만 구독하려면 subscribeWithSelector 미들웨어를 사용, subscribe 함수는 선택자(Selector)와 리스너를 인수로 받음, 선택자는 상태를 반환하는 함수를 말하며 반환 값을 통해 어떤 상태를 구독할지 결정
		Persist 미들웨어를 사용해 스토리지에 상태를 저장하고 불러올 수 있으며 페이지를 새로고침하거나 다시 방문했을 때에도 상태를 유지

4) 클래스형 VS 함수형
	(1) 생명주기
		클래스형: this.state, this.setState, 그리고 componentDidMount, componentDidUpdate, componentWillUnmount 같은 생명주기 메서드 사용
		함수형: useState, useEffect, useReducer 등 Hook으로 상태 관리와 생명주기 대체
	(2) 코드 가독성과 간결함
		클래스형은 this 바인딩 필요, 코드가 장황해짐, 함수형은 this가 필요 없음 → 훨씬 짧고 직관적
	(3) 성능 및 최적화
		초창기에는 클래스형이 더 최적화되어 있다는 얘기도 있었지만, 현재 React 내부 동작은 함수형이 더 효율적이며 React 팀도 함수형을 중심으로 개선을 이어가고 있음
	(4) 페이스북/React 팀은 간결한 코드, Hook 재사용성, 최신 기능 호환성 때문에 함수형 컴포넌트를 권장

2. TypeScript

3. Next.js
1) 리액트 서버 컴포넌트 주의사항
	(1) 서버 컴포넌트에는 브라우저에서 실행될 코드가 포함되면 안된다
	(2) 클라이언트 컴포넌트는 클라이언트에서만 실행되지 않는다
	(3) 클라이언트 컴포넌트에서 서버 컴포넌트를 import 할 수 없다
	(4) 서버 컴포넌트에서 클라이언트 컴포넌트에게 직렬화 되지 않는 Props는 전달 불가하다

2) App Router
	(1) Client Side Rendering 방식으로 처리
	(2) 클라이언트 컴포넌트를 JS Bundle로 보낼 때 서버 컴포넌트를 RSC Payload로 함께 보냄

4. Vue
1) Vue App의 생명 주기
	- Vue 컴포넌트도 React처럼 생성 → 마운트 → 갱신 → 해제, Vue 2에서는 beforeDestroy/destroyed, Vue 3에서는  beforeUnmount/unmounted, Vue 3의 Composition API에서는 onMounted, onUpdated, onUnmounted 같은 함수형 훅 사용
	(1) Creation (생성 단계)
		컴포넌트 인스턴스가 메모리에 올라오지만, 아직 DOM에는 부착되지 않음, 데이터/props 초기화, 이벤트 등록 등, beforeCreate() : 인스턴스가 초기화되기 전 (data, props 접근 불가), created() : 인스턴스 생성 완료 후 (data, props 접근 가능, 하지만 DOM은 아직 준비 안 됨)
	(2) Mounting (마운트 단계)
		템플릿 → 실제 DOM으로 변환되어 브라우저에 표시되는 단계, beforeMount() : DOM에 부착되기 직전, mounted() : DOM에 컴포넌트가 실제로 부착된 후 (DOM 조작, API 호출 가능)
	(3) Updating (갱신 단계)
		props 또는 data가 변경되어 다시 렌더링 될 때, beforeUpdate() : 데이터가 변경되어 DOM 패치 직전, updated() : 가상 DOM → 실제 DOM 패치 완료 후
	(4) Unmounting (제거 단계)
		컴포넌트가 DOM에서 제거될 때, beforeUnmount() (Vue 3) / beforeDestroy() (Vue 2), unmounted() (Vue 3) / destroyed() (Vue 2) → 이벤트 리스너 해제, 타이머 제거 등 정리 작업

5. HTML/JavaScript/CSS
1) JavaScript 버전별 차이
	(1) ES5(2009)
		가장 많이 쓰이는 안정 버전 중 하나. (ES6 나오기 전까지 표준처럼 사용됨), strict mode ("use strict";) 도입 → 암묵적 오류 방지, Array 메서드 추가 (forEach, map, filter, reduce 등), JSON 지원 내장 (JSON.parse, JSON.stringify), Object.defineProperty, Object.keys 같은 메서드 추가.
	(2) ES6(2015, ES2015)
		JavaScript의 대혁신 버전, 현대 JS의 출발점, let/const(블록 스코프 변수), 화살표 함수 (()=>{}), 클래스(class) 문법 도입, 템플릿 리터럴 (백틱 `Hello ${name}`), 디스트럭처링 할당 (const {a, b} = obj), 스프레드/나머지 연산자 (...), 기본 매개변수, Rest 파라미터, 모듈 시스템 (import, export), 프로미스(Promise), Symbol 타입.
	(3) ES2017 이후
		비동기(Async/Await), 옵셔널 체이닝, 최신 배열/객체 유틸, BigInt 등 현대적 기능

6. 


8. 기타
1) Webpack
2) Babel
3) Vite